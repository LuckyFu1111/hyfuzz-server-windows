# ==============================================================================
# HyFuzz Server - Vulnerability Database Module
# File: src/knowledge/vulnerability_db.py
# ==============================================================================
"""
Vulnerability Database Management System

This module provides centralized management for vulnerability data including:
- CWE (Common Weakness Enumeration) storage and retrieval
- CVE (Common Vulnerabilities and Exposures) management
- Vulnerability correlation and relationship mapping
- Search and filtering capabilities
- Database persistence and caching

Usage:
    from src.knowledge.vulnerability_db import VulnerabilityDB

    db = VulnerabilityDB()
    vulnerabilities = db.search_by_type("CWE", "buffer-overflow")
"""

import json
import logging
from typing import Dict, List, Optional, Any, Tuple, Set
from dataclasses import dataclass, asdict, field
from datetime import datetime
from pathlib import Path
import sqlite3
from abc import ABC, abstractmethod
from enum import Enum


# ==============================================================================
# ENUMS AND CONSTANTS
# ==============================================================================

class VulnerabilityType(Enum):
    """Enumeration of vulnerability types"""
    CWE = "cwe"  # Common Weakness Enumeration
    CVE = "cve"  # Common Vulnerabilities and Exposures
    CUSTOM = "custom"  # Custom vulnerability definitions


class SeverityLevel(Enum):
    """CVSS severity classification"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    NONE = "none"


class VulnerabilityStatus(Enum):
    """Vulnerability lifecycle status"""
    ACTIVE = "active"
    DEPRECATED = "deprecated"
    SUPERSEDED = "superseded"
    ARCHIVED = "archived"


# ==============================================================================
# DATA MODELS
# ==============================================================================

@dataclass
class CVEEntry:
    """
    CVE (Common Vulnerabilities and Exposures) entry model

    Attributes:
        cve_id: Unique CVE identifier (e.g., CVE-2021-1234)
        description: Detailed vulnerability description
        severity: CVSS severity level
        cvss_score: CVSS v3.1 base score (0.0-10.0)
        publish_date: Publication date in ISO format
        update_date: Last update date in ISO format
        affected_products: List of affected software/hardware
        related_cwe_ids: Associated CWE identifiers
        references: URLs to external resources
        status: Current vulnerability status
        metadata: Additional custom metadata
    """
    cve_id: str
    description: str
    severity: SeverityLevel
    cvss_score: float
    publish_date: str
    update_date: str
    affected_products: List[str] = field(default_factory=list)
    related_cwe_ids: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    status: VulnerabilityStatus = VulnerabilityStatus.ACTIVE
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary representation"""
        data = asdict(self)
        data['severity'] = self.severity.value
        data['status'] = self.status.value
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CVEEntry':
        """Create instance from dictionary"""
        data = data.copy()
        if isinstance(data.get('severity'), str):
            data['severity'] = SeverityLevel(data['severity'])
        if isinstance(data.get('status'), str):
            data['status'] = VulnerabilityStatus(data['status'])
        return cls(**data)


@dataclass
class CWEEntry:
    """
    CWE (Common Weakness Enumeration) entry model

    Attributes:
        cwe_id: Unique CWE identifier (e.g., CWE-79)
        name: Weakness name
        description: Detailed description
        potential_impact: Impact of the weakness
        related_cwe_ids: Related/parent CWE identifiers
        applicable_platforms: Affected platforms/languages
        related_cve_count: Number of associated CVEs
        metadata: Additional information
    """
    cwe_id: str
    name: str
    description: str
    potential_impact: str
    related_cwe_ids: List[str] = field(default_factory=list)
    applicable_platforms: List[str] = field(default_factory=list)
    related_cve_count: int = 0
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary representation"""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CWEEntry':
        """Create instance from dictionary"""
        return cls(**data)


@dataclass
class VulnerabilityRelation:
    """
    Represents relationships between vulnerabilities

    Attributes:
        source_id: Source vulnerability ID
        target_id: Target vulnerability ID
        relation_type: Type of relationship (parent, child, related, etc.)
        strength: Relation strength (0.0-1.0)
    """
    source_id: str
    target_id: str
    relation_type: str
    strength: float = 1.0


# ==============================================================================
# STORAGE BACKEND INTERFACE
# ==============================================================================

class StorageBackend(ABC):
    """Abstract base class for vulnerability database storage"""

    @abstractmethod
    async def store_cve(self, cve: CVEEntry) -> bool:
        """Store a CVE entry"""
        pass

    @abstractmethod
    async def store_cwe(self, cwe: CWEEntry) -> bool:
        """Store a CWE entry"""
        pass

    @abstractmethod
    async def get_cve(self, cve_id: str) -> Optional[CVEEntry]:
        """Retrieve a CVE entry by ID"""
        pass

    @abstractmethod
    async def get_cwe(self, cwe_id: str) -> Optional[CWEEntry]:
        """Retrieve a CWE entry by ID"""
        pass

    @abstractmethod
    async def search_cves(self, **kwargs) -> List[CVEEntry]:
        """Search CVEs with filters"""
        pass

    @abstractmethod
    async def search_cwes(self, **kwargs) -> List[CWEEntry]:
        """Search CWEs with filters"""
        pass


class InMemoryBackend(StorageBackend):
    """In-memory storage backend for testing and caching"""

    def __init__(self):
        """Initialize in-memory storage"""
        self.cves: Dict[str, CVEEntry] = {}
        self.cwes: Dict[str, CWEEntry] = {}
        self.logger = logging.getLogger(__name__)

    async def store_cve(self, cve: CVEEntry) -> bool:
        """Store CVE in memory"""
        try:
            self.cves[cve.cve_id] = cve
            self.logger.debug(f"Stored CVE: {cve.cve_id}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to store CVE {cve.cve_id}: {e}")
            return False

    async def store_cwe(self, cwe: CWEEntry) -> bool:
        """Store CWE in memory"""
        try:
            self.cwes[cwe.cwe_id] = cwe
            self.logger.debug(f"Stored CWE: {cwe.cwe_id}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to store CWE {cwe.cwe_id}: {e}")
            return False

    async def get_cve(self, cve_id: str) -> Optional[CVEEntry]:
        """Retrieve CVE from memory"""
        return self.cves.get(cve_id)

    async def get_cwe(self, cwe_id: str) -> Optional[CWEEntry]:
        """Retrieve CWE from memory"""
        return self.cwes.get(cwe_id)

    async def search_cves(self, **kwargs) -> List[CVEEntry]:
        """Search CVEs with filters"""
        results = list(self.cves.values())

        if keyword := kwargs.get('keyword'):
            keyword = keyword.lower()
            results = [
                cve for cve in results
                if keyword in cve.description.lower() or
                   keyword in cve.cve_id.lower()
            ]

        if severity := kwargs.get('severity'):
            if isinstance(severity, str):
                severity = SeverityLevel(severity)
            results = [cve for cve in results if cve.severity == severity]

        if cwe_id := kwargs.get('cwe_id'):
            results = [
                cve for cve in results
                if cwe_id in cve.related_cwe_ids
            ]

        return results

    async def search_cwes(self, **kwargs) -> List[CWEEntry]:
        """Search CWEs with filters"""
        results = list(self.cwes.values())

        if keyword := kwargs.get('keyword'):
            keyword = keyword.lower()
            results = [
                cwe for cwe in results
                if keyword in cwe.description.lower() or
                   keyword in cwe.name.lower() or
                   keyword in cwe.cwe_id.lower()
            ]

        if platform := kwargs.get('platform'):
            platform = platform.lower()
            results = [
                cwe for cwe in results
                if any(platform in p.lower() for p in cwe.applicable_platforms)
            ]

        return results


# ==============================================================================
# MAIN VULNERABILITY DATABASE CLASS
# ==============================================================================

class VulnerabilityDB:
    """
    Centralized Vulnerability Database Management System

    Provides functionality for:
    - Storing and retrieving CVE/CWE data
    - Searching and filtering vulnerabilities
    - Managing relationships between vulnerabilities
    - Caching and performance optimization

    Example:
        db = VulnerabilityDB()
        cve = CVEEntry(
            cve_id="CVE-2021-1234",
            description="Buffer overflow vulnerability",
            severity=SeverityLevel.HIGH,
            cvss_score=8.5,
            publish_date="2021-01-15",
            update_date="2021-01-15"
        )
        await db.add_cve(cve)
        results = await db.search_vulnerabilities("buffer overflow")
    """

    def __init__(
        self,
        backend: Optional[StorageBackend] = None,
        cache_enabled: bool = True,
        max_cache_size: int = 1000
    ):
        """
        Initialize VulnerabilityDB

        Args:
            backend: Storage backend instance (default: InMemoryBackend)
            cache_enabled: Enable caching for frequent queries
            max_cache_size: Maximum number of cached items
        """
        self.backend = backend or InMemoryBackend()
        self.cache_enabled = cache_enabled
        self.max_cache_size = max_cache_size
        self.cache: Dict[str, Any] = {}
        self.logger = logging.getLogger(__name__)

        # Relationships storage
        self.relations: List[VulnerabilityRelation] = []

        self.logger.info("VulnerabilityDB initialized")

    async def add_cve(self, cve: CVEEntry) -> bool:
        """
        Add a CVE entry to the database

        Args:
            cve: CVEEntry instance to add

        Returns:
            True if successful, False otherwise
        """
        try:
            result = await self.backend.store_cve(cve)
            if result and self.cache_enabled:
                self._invalidate_cache()
            return result
        except Exception as e:
            self.logger.error(f"Error adding CVE {cve.cve_id}: {e}")
            return False

    async def add_cwe(self, cwe: CWEEntry) -> bool:
        """
        Add a CWE entry to the database

        Args:
            cwe: CWEEntry instance to add

        Returns:
            True if successful, False otherwise
        """
        try:
            result = await self.backend.store_cwe(cwe)
            if result and self.cache_enabled:
                self._invalidate_cache()
            return result
        except Exception as e:
            self.logger.error(f"Error adding CWE {cwe.cwe_id}: {e}")
            return False

    async def get_cve(self, cve_id: str) -> Optional[CVEEntry]:
        """
        Retrieve CVE by ID

        Args:
            cve_id: CVE identifier

        Returns:
            CVEEntry if found, None otherwise
        """
        cache_key = f"cve:{cve_id}"
        if self.cache_enabled and cache_key in self.cache:
            return self.cache[cache_key]

        cve = await self.backend.get_cve(cve_id)
        if cve and self.cache_enabled:
            self._cache_item(cache_key, cve)
        return cve

    async def get_cwe(self, cwe_id: str) -> Optional[CWEEntry]:
        """
        Retrieve CWE by ID

        Args:
            cwe_id: CWE identifier

        Returns:
            CWEEntry if found, None otherwise
        """
        cache_key = f"cwe:{cwe_id}"
        if self.cache_enabled and cache_key in self.cache:
            return self.cache[cache_key]

        cwe = await self.backend.get_cwe(cwe_id)
        if cwe and self.cache_enabled:
            self._cache_item(cache_key, cwe)
        return cwe

    async def search_cves(
        self,
        keyword: Optional[str] = None,
        severity: Optional[str] = None,
        cwe_id: Optional[str] = None,
        limit: int = 100
    ) -> List[CVEEntry]:
        """
        Search for CVEs with multiple filters

        Args:
            keyword: Search keyword in description
            severity: Filter by severity level
            cwe_id: Filter by related CWE ID
            limit: Maximum number of results

        Returns:
            List of matching CVEEntry instances
        """
        search_params = {}
        if keyword:
            search_params['keyword'] = keyword
        if severity:
            search_params['severity'] = severity
        if cwe_id:
            search_params['cwe_id'] = cwe_id

        cache_key = f"search_cves:{json.dumps(search_params, sort_keys=True)}"
        if self.cache_enabled and cache_key in self.cache:
            return self.cache[cache_key][:limit]

        results = await self.backend.search_cves(**search_params)

        if self.cache_enabled:
            self._cache_item(cache_key, results)

        return results[:limit]

    async def search_cwes(
        self,
        keyword: Optional[str] = None,
        platform: Optional[str] = None,
        limit: int = 100
    ) -> List[CWEEntry]:
        """
        Search for CWEs with multiple filters

        Args:
            keyword: Search keyword in name/description
            platform: Filter by applicable platform
            limit: Maximum number of results

        Returns:
            List of matching CWEEntry instances
        """
        search_params = {}
        if keyword:
            search_params['keyword'] = keyword
        if platform:
            search_params['platform'] = platform

        cache_key = f"search_cwes:{json.dumps(search_params, sort_keys=True)}"
        if self.cache_enabled and cache_key in self.cache:
            return self.cache[cache_key][:limit]

        results = await self.backend.search_cwes(**search_params)

        if self.cache_enabled:
            self._cache_item(cache_key, results)

        return results[:limit]

    async def search_vulnerabilities(
        self,
        query: str,
        vuln_type: Optional[VulnerabilityType] = None,
        limit: int = 50
    ) -> Dict[str, List[Any]]:
        """
        Unified vulnerability search across all types

        Args:
            query: Search query string
            vuln_type: Specific type to search (None = all types)
            limit: Maximum results per type

        Returns:
            Dictionary with 'cves' and 'cwes' keys containing results
        """
        results = {"cves": [], "cwes": [], "timestamp": datetime.now().isoformat()}

        if vuln_type in (None, VulnerabilityType.CVE):
            cves = await self.search_cves(keyword=query, limit=limit)
            results["cves"] = cves

        if vuln_type in (None, VulnerabilityType.CWE):
            cwes = await self.search_cwes(keyword=query, limit=limit)
            results["cwes"] = cwes

        self.logger.info(
            f"Vulnerability search for '{query}': "
            f"{len(results['cves'])} CVEs, {len(results['cwes'])} CWEs"
        )
        return results

    def add_relation(
        self,
        source_id: str,
        target_id: str,
        relation_type: str = "related",
        strength: float = 1.0
    ) -> bool:
        """
        Add a relationship between vulnerabilities

        Args:
            source_id: Source vulnerability ID
            target_id: Target vulnerability ID
            relation_type: Type of relationship
            strength: Relationship strength (0.0-1.0)

        Returns:
            True if successful
        """
        try:
            relation = VulnerabilityRelation(
                source_id=source_id,
                target_id=target_id,
                relation_type=relation_type,
                strength=max(0.0, min(1.0, strength))
            )
            self.relations.append(relation)
            self.logger.debug(f"Added relation: {source_id} -> {target_id}")
            return True
        except Exception as e:
            self.logger.error(f"Error adding relation: {e}")
            return False

    def get_related_vulnerabilities(
        self,
        vuln_id: str,
        relation_type: Optional[str] = None
    ) -> List[Tuple[str, str, float]]:
        """
        Get vulnerabilities related to a given ID

        Args:
            vuln_id: Vulnerability ID
            relation_type: Filter by relation type (optional)

        Returns:
            List of (target_id, relation_type, strength) tuples
        """
        results = []
        for rel in self.relations:
            if rel.source_id == vuln_id:
                if relation_type is None or rel.relation_type == relation_type:
                    results.append((rel.target_id, rel.relation_type, rel.strength))
        return results

    async def get_vulnerability_stats(self) -> Dict[str, Any]:
        """
        Get statistics about the database

        Returns:
            Dictionary containing database statistics
        """
        stats = {
            "timestamp": datetime.now().isoformat(),
            "total_relations": len(self.relations),
            "cache_size": len(self.cache) if self.cache_enabled else 0,
        }

        if hasattr(self.backend, 'cves'):
            stats["total_cves"] = len(self.backend.cves)
        if hasattr(self.backend, 'cwes'):
            stats["total_cwes"] = len(self.backend.cwes)

        return stats

    def _invalidate_cache(self) -> None:
        """Invalidate entire cache"""
        self.cache.clear()
        self.logger.debug("Cache invalidated")

    def _cache_item(self, key: str, value: Any) -> None:
        """Cache a single item with size limit"""
        if len(self.cache) >= self.max_cache_size:
            # Remove oldest item (simple FIFO strategy)
            self.cache.pop(next(iter(self.cache)))
        self.cache[key] = value

    async def bulk_import_cves(self, cves_data: List[Dict[str, Any]]) -> int:
        """
        Bulk import CVE data from dictionaries

        Args:
            cves_data: List of CVE data dictionaries

        Returns:
            Number of successfully imported CVEs
        """
        imported = 0
        for cve_dict in cves_data:
            try:
                cve = CVEEntry.from_dict(cve_dict)
                if await self.add_cve(cve):
                    imported += 1
            except Exception as e:
                self.logger.warning(f"Failed to import CVE: {e}")

        self.logger.info(f"Bulk imported {imported}/{len(cves_data)} CVEs")
        return imported

    async def bulk_import_cwes(self, cwes_data: List[Dict[str, Any]]) -> int:
        """
        Bulk import CWE data from dictionaries

        Args:
            cwes_data: List of CWE data dictionaries

        Returns:
            Number of successfully imported CWEs
        """
        imported = 0
        for cwe_dict in cwes_data:
            try:
                cwe = CWEEntry.from_dict(cwe_dict)
                if await self.add_cwe(cwe):
                    imported += 1
            except Exception as e:
                self.logger.warning(f"Failed to import CWE: {e}")

        self.logger.info(f"Bulk imported {imported}/{len(cwes_data)} CWEs")
        return imported


# ==============================================================================
# UNIT TESTS
# ==============================================================================

async def run_tests():
    """
    Comprehensive test suite for VulnerabilityDB
    Validates core functionality including storage, retrieval, and search
    """
    import asyncio

    print("\n" + "="*70)
    print("VULNERABILITY DATABASE UNIT TESTS")
    print("="*70 + "\n")

    # Initialize database
    db = VulnerabilityDB(cache_enabled=True)
    test_passed = 0
    test_failed = 0

    try:
        # Test 1: Add and retrieve CVE
        print("[TEST 1] Adding and retrieving CVE...")
        cve1 = CVEEntry(
            cve_id="CVE-2021-1234",
            description="Critical buffer overflow in library X",
            severity=SeverityLevel.CRITICAL,
            cvss_score=9.5,
            publish_date="2021-01-15",
            update_date="2021-01-15",
            affected_products=["LibX < 1.5", "LibX-NG < 2.0"],
            related_cwe_ids=["CWE-120", "CWE-122"]
        )

        if await db.add_cve(cve1):
            retrieved = await db.get_cve("CVE-2021-1234")
            if retrieved and retrieved.cve_id == "CVE-2021-1234":
                print("✓ PASSED: CVE storage and retrieval\n")
                test_passed += 1
            else:
                print("✗ FAILED: Retrieved CVE mismatch\n")
                test_failed += 1
        else:
            print("✗ FAILED: Could not add CVE\n")
            test_failed += 1

        # Test 2: Add and retrieve CWE
        print("[TEST 2] Adding and retrieving CWE...")
        cwe1 = CWEEntry(
            cwe_id="CWE-120",
            name="Buffer Copy without Checking Size",
            description="Buffer copy operations that do not verify sufficient space",
            potential_impact="Memory corruption, code execution",
            applicable_platforms=["C", "C++", "Assembly"],
            related_cve_count=1500
        )

        if await db.add_cwe(cwe1):
            retrieved = await db.get_cwe("CWE-120")
            if retrieved and retrieved.cwe_id == "CWE-120":
                print("✓ PASSED: CWE storage and retrieval\n")
                test_passed += 1
            else:
                print("✗ FAILED: Retrieved CWE mismatch\n")
                test_failed += 1
        else:
            print("✗ FAILED: Could not add CWE\n")
            test_failed += 1

        # Test 3: Search CVEs by severity
        print("[TEST 3] Searching CVEs by severity...")
        cve2 = CVEEntry(
            cve_id="CVE-2021-5678",
            description="Medium severity issue",
            severity=SeverityLevel.MEDIUM,
            cvss_score=5.5,
            publish_date="2021-02-01",
            update_date="2021-02-01"
        )
        await db.add_cve(cve2)

        high_severity = await db.search_cves(severity="critical", limit=10)
        if len(high_severity) >= 1:
            print(f"✓ PASSED: Found {len(high_severity)} critical CVEs\n")
            test_passed += 1
        else:
            print("✗ FAILED: No critical CVEs found\n")
            test_failed += 1

        # Test 4: Search CWEs by keyword
        print("[TEST 4] Searching CWEs by keyword...")
        cwe2 = CWEEntry(
            cwe_id="CWE-79",
            name="Improper Neutralization of Input During Web Page Generation",
            description="The software does not properly filter or escape user input before output",
            potential_impact="XSS attacks and code injection",
            applicable_platforms=["Web", "JavaScript"],
            related_cve_count=2000
        )
        await db.add_cwe(cwe2)

        results = await db.search_cwes(keyword="buffer", limit=10)
        if len(results) >= 1:
            print(f"✓ PASSED: Found {len(results)} CWEs with 'buffer' keyword\n")
            test_passed += 1
        else:
            print("✗ FAILED: No results for buffer keyword\n")
            test_failed += 1

        # Test 5: Unified vulnerability search
        print("[TEST 5] Unified vulnerability search...")
        search_results = await db.search_vulnerabilities("overflow", limit=10)
        total_results = len(search_results["cves"]) + len(search_results["cwes"])
        if total_results >= 1:
            print(f"✓ PASSED: Found {total_results} total results (CVEs: {len(search_results['cves'])}, "
                  f"CWEs: {len(search_results['cwes'])})\n")
            test_passed += 1
        else:
            print("✗ FAILED: No results for unified search\n")
            test_failed += 1

        # Test 6: Add and retrieve relations
        print("[TEST 6] Adding and retrieving vulnerability relations...")
        if db.add_relation("CVE-2021-1234", "CWE-120", "exploits", 0.95):
            relations = db.get_related_vulnerabilities("CVE-2021-1234")
            if len(relations) >= 1 and relations[0][0] == "CWE-120":
                print(f"✓ PASSED: Found {len(relations)} related vulnerabilities\n")
                test_passed += 1
            else:
                print("✗ FAILED: Related vulnerability not found\n")
                test_failed += 1
        else:
            print("✗ FAILED: Could not add relation\n")
            test_failed += 1

        # Test 7: Get database statistics
        print("[TEST 7] Retrieving database statistics...")
        stats = await db.get_vulnerability_stats()
        if stats and "total_cves" in stats and "total_cwes" in stats:
            print(f"✓ PASSED: Database statistics retrieved")
            print(f"  - Total CVEs: {stats.get('total_cves', 0)}")
            print(f"  - Total CWEs: {stats.get('total_cwes', 0)}")
            print(f"  - Relations: {stats.get('total_relations', 0)}\n")
            test_passed += 1
        else:
            print("✗ FAILED: Could not retrieve statistics\n")
            test_failed += 1

        # Test 8: Bulk import
        print("[TEST 8] Bulk importing vulnerabilities...")
        bulk_cves = [
            {
                "cve_id": f"CVE-2021-{1000+i}",
                "description": f"Test vulnerability {i}",
                "severity": "high",
                "cvss_score": 7.5,
                "publish_date": "2021-03-01",
                "update_date": "2021-03-01"
            }
            for i in range(5)
        ]
        imported = await db.bulk_import_cves(bulk_cves)
        if imported == 5:
            print(f"✓ PASSED: Successfully bulk imported {imported} CVEs\n")
            test_passed += 1
        else:
            print(f"✗ FAILED: Expected 5 imports, got {imported}\n")
            test_failed += 1

        # Test 9: Cache functionality
        print("[TEST 9] Testing cache functionality...")
        await db.get_cve("CVE-2021-1234")  # First access - cache miss
        cached_item = await db.get_cve("CVE-2021-1234")  # Second access - cache hit
        if cached_item and len(db.cache) > 0:
            print(f"✓ PASSED: Cache working ({len(db.cache)} items cached)\n")
            test_passed += 1
        else:
            print("✗ FAILED: Cache not functioning\n")
            test_failed += 1

        # Test 10: CVE to CWE relationship search
        print("[TEST 10] Searching CVEs by related CWE...")
        cve_by_cwe = await db.search_cves(cwe_id="CWE-120", limit=10)
        if len(cve_by_cwe) >= 1:
            print(f"✓ PASSED: Found {len(cve_by_cwe)} CVEs related to CWE-120\n")
            test_passed += 1
        else:
            print("✗ FAILED: No CVEs found for CWE-120\n")
            test_failed += 1

    except Exception as e:
        print(f"✗ TEST ERROR: {e}\n")
        test_failed += 1

    # Summary
    print("="*70)
    print(f"TEST SUMMARY: {test_passed} PASSED, {test_failed} FAILED")
    print(f"Success Rate: {(test_passed / (test_passed + test_failed) * 100):.1f}%")
    print("="*70 + "\n")

    return test_passed, test_failed


# ==============================================================================
# ENTRY POINT
# ==============================================================================

if __name__ == "__main__":
    import asyncio

    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # Run tests
    asyncio.run(run_tests())